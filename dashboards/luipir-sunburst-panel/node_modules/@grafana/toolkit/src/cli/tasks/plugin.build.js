"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var useSpinner_1 = require("../utils/useSpinner");
var tests_1 = require("./plugin/tests");
var task_1 = require("./task");
var rimraf_1 = tslib_1.__importDefault(require("rimraf"));
var path_1 = require("path");
var util_1 = require("util");
var globby_1 = tslib_1.__importDefault(require("globby"));
var execa_1 = tslib_1.__importDefault(require("execa"));
var fs_1 = require("fs");
var eslint_1 = require("eslint");
var bundle_1 = require("./plugin/bundle");
var access = fs_1.promises.access, copyFile = fs_1.promises.copyFile;
var COPYFILE_EXCL = fs_1.constants.COPYFILE_EXCL;
var rimraf = util_1.promisify(rimraf_1.default);
exports.bundlePlugin = useSpinner_1.useSpinner('Compiling...', function (options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, bundle_1.bundlePlugin(options)];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); });
exports.clean = useSpinner_1.useSpinner('Cleaning', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, rimraf(process.cwd() + "/dist")];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); });
var copyIfNonExistent = function (srcPath, destPath) {
    return copyFile(srcPath, destPath, COPYFILE_EXCL)
        .then(function () { return console.log("Created: " + destPath); })
        .catch(function (error) {
        if (error.code !== 'EEXIST') {
            throw error;
        }
    });
};
exports.prepare = useSpinner_1.useSpinner('Preparing', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Promise.all([
                    // Copy only if local tsconfig does not exist.  Otherwise this will work, but have odd behavior
                    copyIfNonExistent(path_1.resolve(__dirname, '../../config/tsconfig.plugin.local.json'), path_1.resolve(process.cwd(), 'tsconfig.json')),
                    // Copy only if local prettierrc does not exist.  Otherwise this will work, but have odd behavior
                    copyIfNonExistent(path_1.resolve(__dirname, '../../config/prettier.plugin.rc.js'), path_1.resolve(process.cwd(), '.prettierrc.js')),
                ])];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
// @ts-ignore
var typecheckPlugin = useSpinner_1.useSpinner('Typechecking', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, execa_1.default('tsc', ['--noEmit'])];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
var getTypescriptSources = function () { return globby_1.default(path_1.resolve(process.cwd(), 'src/**/*.+(ts|tsx)')); };
// @ts-ignore
var getStylesSources = function () { return globby_1.default(path_1.resolve(process.cwd(), 'src/**/*.+(scss|css)')); };
exports.lintPlugin = useSpinner_1.useSpinner('Linting', function (_a) {
    var fix = (_a === void 0 ? {} : _a).fix;
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _b, configFile, cli, report, _c, _d, errorCount, results, warningCount, formatter;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _e.trys.push([0, 2, , 3]);
                    // Show a warning if the tslint file exists
                    return [4 /*yield*/, access(path_1.resolve(process.cwd(), 'tslint.json'))];
                case 1:
                    // Show a warning if the tslint file exists
                    _e.sent();
                    console.log('\n');
                    console.log('--------------------------------------------------------------');
                    console.log('NOTE: @grafana/toolkit has migrated to use eslint');
                    console.log('Update your configs to use .eslintrc rather than tslint.json');
                    console.log('--------------------------------------------------------------');
                    return [3 /*break*/, 3];
                case 2:
                    _b = _e.sent();
                    return [3 /*break*/, 3];
                case 3: return [4 /*yield*/, globby_1.default(path_1.resolve(process.cwd(), '.eslintrc?(.cjs|.js|.json|.yaml|.yml)')).then(function (filePaths) {
                        if (filePaths.length > 0) {
                            return filePaths[0];
                        }
                        else {
                            return path_1.resolve(__dirname, '../../config/eslint.plugin.json');
                        }
                    })];
                case 4:
                    configFile = _e.sent();
                    cli = new eslint_1.CLIEngine({
                        configFile: configFile,
                        fix: fix,
                    });
                    _d = (_c = cli).executeOnFiles;
                    return [4 /*yield*/, getTypescriptSources()];
                case 5:
                    report = _d.apply(_c, [_e.sent()]);
                    if (fix) {
                        eslint_1.CLIEngine.outputFixes(report);
                    }
                    errorCount = report.errorCount, results = report.results, warningCount = report.warningCount;
                    if (errorCount > 0 || warningCount > 0) {
                        formatter = cli.getFormatter();
                        console.log('\n');
                        console.log(formatter(results));
                        console.log('\n');
                        throw new Error(errorCount + warningCount + " linting errors found in " + results.length + " files");
                    }
                    return [2 /*return*/];
            }
        });
    });
});
exports.pluginBuildRunner = function (_a) {
    var coverage = _a.coverage;
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, exports.prepare()];
                case 1:
                    _b.sent();
                    return [4 /*yield*/, exports.lintPlugin({ fix: false })];
                case 2:
                    _b.sent();
                    return [4 /*yield*/, tests_1.testPlugin({ updateSnapshot: false, coverage: coverage, watch: false })];
                case 3:
                    _b.sent();
                    return [4 /*yield*/, exports.bundlePlugin({ watch: false, production: true })];
                case 4:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    });
};
exports.pluginBuildTask = new task_1.Task('Build plugin', exports.pluginBuildRunner);
//# sourceMappingURL=plugin.build.js.map